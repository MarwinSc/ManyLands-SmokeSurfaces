#version 430
#define PI 3.1415926538
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in; // work group size

layout(std430, binding = 0) buffer Pos1 { vec4 Position_In[]; };
layout(std430, binding = 1) buffer Indices { uint Indices_In[]; };
layout(std430, binding = 2) buffer Adjacency { int Adjacency_In[]; };
layout(std430, binding = 3) buffer Adjacency_Offset { ivec2 Adjacency_Offset_In[]; };
layout(std430, binding = 4) buffer Normals { vec4 Normals_In[]; };
layout(std430, binding = 5) buffer Opacity { float Opacity_Out[]; };
layout (binding = 6, offset = 0) uniform atomic_uint Count; 

uniform vec3 camera;
uniform float surface_height;
uniform float shape_exponent;

float calculate_area(vec3 v1, vec3 v2, vec3 v3);
float calculate_angle(vec3 v_1, vec3 v_2, vec3 v_3);
float cotan(float angle);
bool in_array(int[6] arr, uint elem);
float triangle_area(vec3 v1, vec3 v2, vec3 v3);
float angle_between_vectors(vec3 v1, vec3 v2);
float calculate_density(vec3 v1, vec3 v2, vec3 v3, vec3 camera, vec3 normal, float surface_height);
float calculate_shape(vec3 v1, vec3 v2, vec3 v3);

void main() {

    uint nr = atomicCounterIncrement(Count);
    vec4 aPos = Position_In[nr];
    int offset = Adjacency_Offset_In[nr][0];
    int nr_of_neighbours = Adjacency_Offset_In[nr][1];
    //int visited[6] = int[6](-1,-1,-1,-1,-1,-1);

    float sum_area = 0.0f;
    float sum_angle = 0.0f;

    vec3 laplace_beltrami = vec3(0.0f,0.0f,0.0f);
    float debug = 0.0f;

    float smoke_max = 0.0f;
    float shape_min = 1.0f;
    float density_min = 1.0f;

    for (int i = 0; i<nr_of_neighbours; i++){
       int adjacent_triangle_idx = Adjacency_In[offset + i];

       uint vertex_idx1 = Indices_In[adjacent_triangle_idx * 3];
       uint vertex_idx2 = Indices_In[adjacent_triangle_idx * 3 + 1];
       uint vertex_idx3 = Indices_In[adjacent_triangle_idx * 3 + 2];

       vec3 v1 = vec3(aPos.x,aPos.y,aPos.z);
       vec3 v2;
       vec3 v3;

       uint newV2index;

       if(nr == vertex_idx1){
            v2 = vec3(Position_In[vertex_idx2].xyz);
            v3 = vec3(Position_In[vertex_idx3].xyz);
            //newV2index = vertex_idx2;
       }else if(nr == vertex_idx2){
            v2 = vec3(Position_In[vertex_idx3].xyz);
            v3 = vec3(Position_In[vertex_idx1].xyz);
            //newV2index = vertex_idx3;
       }else{// if(nr == vertex_idx3){
            v2 = vec3(Position_In[vertex_idx1].xyz);
            v3 = vec3(Position_In[vertex_idx2].xyz);
            //newV2index = vertex_idx1;
       }

       float density = calculate_density(v1, v2, v3, camera, Normals_In[vertex_idx1].xyz, surface_height);
       density_min = min(density_min, density);
       //density_min = density;
       float shape = calculate_shape(v1, v2, v3);
       shape_min = min(shape_min, shape);

       sum_angle += (180/PI) * calculate_angle(v1,v2,v3);
       sum_area += calculate_area(v1,v2,v3);

       vec3 e = (v2 - v1) / length((v2 - v1));
       float temp = dot(e,Normals_In[nr].xyz);
       if(temp > smoke_max){
            smoke_max = temp;
       }

    }


    float b = 2.0f;
    float curvature = clamp(1 - b * smoke_max,0.0,1.0);

    Opacity_Out[nr] = density_min * shape_min * curvature;
}

float triangle_area(vec3 v1, vec3 v2, vec3 v3)
{
    vec3 c1 = (v2 - v1);
    vec3 c2 = (v3 - v1);
    vec3 r = cross(c1,c2);
    return sqrt(r.x * r.x + r.y * r.y + r.z * r.z) / 2.0;
}

float angle_between_vectors(vec3 v1, vec3 v2)
{
    v1 = normalize(v1);
    v2 = normalize(v2);
    float d = clamp(dot(v1,v2),-1.0,1.0);
    return acos(d) * (180.0 / 3.141592653589793238463);
}

float calculate_density(vec3 v1, vec3 v2, vec3 v3, vec3 camera, vec3 normal, float surface_height){
    //alpha density
    float area = triangle_area(v1,v2,v3);
    float angle = angle_between_vectors(camera,normal);
    //return camera.x + camera.z + camera.y;
    return clamp(surface_height / (area * angle), 0.0f, 1.0f);
}

float calculate_shape(vec3 v1, vec3 v2, vec3 v3){
    //alpha shape
    float area = triangle_area(v1,v2,v3);
    float d0 = length(v3-v2);
    float d1 = length(v1-v3);
    float d2 = length(v2-v1);
    float max_distance = max(d0,max(d1,d2));
    return clamp(pow((4.0 * area) / (sqrt(3) * max_distance), shape_exponent) , 0.0, 1.0);
}

bool in_array(int[6] arr, uint elem){
    for (int i = 0; i < 6; i++){
        if(arr[i] == elem){
            return true;
        }
    }
    return false;
}

float cotan(float angle){
    return 1/tan(angle);
}

float calculate_angle(vec3 v_1, vec3 v_2, vec3 v_3){
    vec3 v1_2 = v_2 - v_1;
    vec3 v1_3 = v_3 - v_1; 
    return acos(dot(normalize(v1_2),normalize(v1_3)));
}

float calculate_area(vec3 v1, vec3 v2, vec3 v3){
    vec3 v1_2 = v2 - v1;
    vec3 v1_3 = v3 - v1; 
    return 0.5 * length(cross(v1_2,v1_3));
}

